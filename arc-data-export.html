<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer-element.html">
<script>
/**
 * An element to handle data export for ARC.
 *
 * @customElement
 * @polymer
 * @memberof LogicElements
 */
class ArcDataExport extends Polymer.Element {
  static get is() {return 'arc-data-export';}
  static get properties() {
    return {
      /**
       * Hosting application version number. If not set it sends `app-version`
       * custom event to query for the application version number.
       */
      appVersion: {type: String, value: 'unknown'},
      /**
       * A size of datastore read operation in one call.
       */
      dbChunk: {
        type: Number,
        value: 1000
      },
      /**
       * If set it uses arc electron session state module to read cookie data
       */
      electronCookies: Boolean
    };
  }

  constructor() {
    super();
    this._exportHandler = this._exportHandler.bind(this);
  }

  connectedCallback() {
    super.connectedCallback();
    window.addEventListener('export-data', this._exportHandler);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener('export-data', this._exportHandler);
  }

  _exportHandler(e) {
    if (e.defaultPrevented) {
      return;
    }
    e.preventDefault();
    let result;
    switch (e.detail.type) {
      case 'arc-export':
        result = this.arcExport(e.detail);
        break;
      case 'items-export':
        result = this.itemsExport(e.detail);
        break;
      default:
        result = this.dataExport(e.detail);
        break;
    }
    e.detail.result = result;
  }

  dataExport(opts) {
    const file = opts.file || 'arc-data-export.json';
    const destination = opts.destination;
    let data = opts.data;
    switch (destination) {
      case 'file': return this._exportFile(data, file);
      case 'drive': return this._exportDrive(data, file);
      default: return Promise.reject(`Unknown destination ${destination}`);
    }
  }
  /**
   * Generates and saves ARC export object from user data.
   * @param {Object} opts Export options. See
   * https://github.com/advanced-rest-client/api-components-api/blob/master/docs/export-event.md
   * for details.
   * @return {Promise} Promise resolved to a result of saving a file.
   * Google Drive results with create response.
   */
  arcExport(opts) {
    const file = opts.file || 'arc-data-export.json';
    const destination = opts.destination;
    const data = opts.data;
    const dataKeys = Object.keys(data);
    const exportData = {};
    let databases = [];
    for (let i = 0, len = dataKeys.length; i < len; i++) {
      const key = dataKeys[i];
      const value = data[key];
      if (typeof value === 'boolean' && value) {
        databases[databases.length] = key;
      } else if (value instanceof Array) {
        exportData[key] = value;
      } else {
        console.warn(`Unknown export data configuration. ${key}.`);
      }
    }
    databases = this._getDatabasesInfo(databases);
    const promises = [];
    if (this.electronCookies && 'cookies' in databases) {
      promises.push(this._queryCookies());
      delete databases.cookies;
    }
    Object.keys(databases).forEach((name) => {
      promises.push(this._getDatabaseEntries(name));
    });
    return Promise.all(promises)
    .then((result) => {
      result.forEach((data) => {
        if (data.name === 'cookies' && this.electronCookies) {
          databases.cookies = 'cookies';
        }
        exportData[databases[data.name]] = data.data;
      });
      return exportData;
    })
    .then((exportData) => this.createExportObject(exportData))
    .then((data) => {
      switch (destination) {
        case 'file': return this._exportFile(data, file);
        case 'drive': return this._exportDrive(data, file);
        default: return Promise.reject(new Error(`Unknown destination ${destination}`));
      }
    });
  }
  /**
   * Exports data that are already retreived from the datastore.
   * It calls `createExportObject` to prepare arc export object so the `items`
   * object set on the `opts` has to have the same structure as the function's
   * only argument.
   * @param {Object} opts Export options:
   * - `file` (String) Optional. Export file name.
   * - `destination` (String) `drive` or `file`.
   * - `items` (Object) The same structore as `opts` argument for `createExportObject()`
   * - `kind` (String) Opional. Export item kind property.
   * @return {Promise}
   */
  itemsExport(opts) {
    const file = opts.file || 'arc-data-export.json';
    const destination = opts.destination;
    const items = opts.items;
    if (opts.kind) {
      items.kind = opts.kind;
    }
    const data = this.createExportObject(items);
    switch (destination) {
      case 'file': return this._exportFile(data, file);
      case 'drive': return this._exportDrive(data, file);
      default: return Promise.reject(`Unknown destination ${destination}`);
    }
  }
  /**
   * Creates an export object for the data.
   *
   * @param {Object} opts Export options. Available keys:
   * -   `requests` (Array) List of requests to export
   * -   `projects` (Array) List of projects to export
   * -   `history` (Array) List of history requests to export
   * -   `websocket-url-history` (Array) List of url history object for WS to export
   * -   `url-history` (Array) List of URL history objects to export
   * -   `variables` (Array) List of variables to export
   * -   `headers-sets` (Array) List of the headers sets objects to export
   * -   `auth-data` (Array) List of the auth data objects to export
   * -   `cookies` (Array) List of cookies to export
   * -   `kind` (String) The `kind` property of the top export declaration.
   *      Default to `ARC#AllDataExport`
   * @return {Object} ARC export object declaration.
   */
  createExportObject(opts) {
    opts = opts || {};
    const appVersion = this.appVersion;
    const result = {
      createdAt: new Date().toISOString(),
      version: appVersion,
      kind: opts.kind || 'ARC#AllDataExport'
    };
    if (opts.requests && opts.requests.length) {
      result.requests = this._prepareRequestsList(opts.requests);
    }
    if (opts.projects && opts.projects.length) {
      result.projects = this._prepareProjectsList(opts.projects);
    }
    if (opts.history && opts.history.length) {
      result.history = this._prepareHistoryDataList(opts.history);
    }
    const wsHistory = opts['websocket-url-history'];
    if (wsHistory && wsHistory.length) {
      result['websocket-url-history'] = this._prepareWsUrlHistoryData(wsHistory);
    }
    const urlHistory = opts['url-history'];
    if (urlHistory && urlHistory.length) {
      result['url-history'] = this._prepareUrlHistoryData(urlHistory);
    }
    if (opts.variables && opts.variables.length) {
      result.variables = this._prepareVariablesData(opts.variables);
    }
    if (('headers-sets' in opts) && opts['headers-sets'].length) {
      result['headers-sets'] = this._prepareHeadersSetsData(opts['headers-sets']);
    }
    if (('auth-data' in opts) && opts['auth-data'].length) {
      result['auth-data'] = this._prepareAuthData(opts['auth-data']);
    }
    if (opts.cookies && opts.cookies.length) {
      result.cookies = this._prepareCookieData(opts.cookies);
    }
    if (('host-rules' in opts) && opts['host-rules'].length) {
      result['host-rules'] = this._prepareHostRulesData(opts['host-rules']);
    }
    return result;
  }
  /**
   * A function used with `electronCookies` flag.
   * It queries `electron-session-state` node module for cookies instead of
   * the database.
   * @return {Promise}
   */
  _queryCookies() {
    const e = new CustomEvent('session-cookie-list-all', {
      bubbles: true,
      composed: true,
      cancelable: true,
      detail: {}
    });
    this.dispatchEvent(e);
    if (!e.defaultPrevented) {
      console.error('electron-session-state module not active');
      return Promise.resolve([]);
    }
    return e.detail.result
    .then((data) => {
      return {
        name: 'cookies',
        data
      };
    });
  }

  _prepareRequestsList(requests) {
    const result = requests.map((item) => {
      if (item.legacyProject) {
        if (item.projects) {
          item.projects[item.projects.length] = item.legacyProject;
        } else {
          item.projects = [item.legacyProject];
        }
        delete item.legacyProject;
      }
      item.kind = 'ARC#RequestData';
      item.key = item._id;
      delete item._rev;
      delete item._id;
      return item;
    });
    return result;
  }

  _prepareProjectsList(projects) {
    return projects.map((item) => {
      item.kind = 'ARC#ProjectData';
      item.key = item._id;
      delete item._rev;
      delete item._id;
      return item;
    });
  }

  _prepareHistoryDataList(history) {
    const result = history.map((item) => {
      delete item._rev;
      delete item._id;
      item.kind = 'ARC#HistoryData';
      return item;
    });
    return result;
  }

  _prepareWsUrlHistoryData(history) {
    const result = history.map((item) => {
      item.key = item._id;
      delete item._rev;
      delete item._id;
      item.kind = 'ARC#WebsocketHistoryData';
      return item;
    });
    return result;
  }

  _prepareUrlHistoryData(history) {
    const result = history.map((item) => {
      item.key = item._id;
      delete item._rev;
      delete item._id;
      item.kind = 'ARC#UrlHistoryData';
      return item;
    });
    return result;
  }

  _prepareVariablesData(variables) {
    const result = [];
    variables.forEach((item) => {
      if (!item.environment) {
        // PouchDB creates some views in the main datastore and it is added to
        // get all docs function without any reason. It should be eleminated
        return;
      }
      item.key = item._id;
      delete item._rev;
      delete item._id;
      item.kind = 'ARC#Variable';
      result.push(item);
    });
    return result;
  }

  _prepareHeadersSetsData(sets) {
    const result = sets.map((item) => {
      item.key = item._id;
      delete item._rev;
      delete item._id;
      item.kind = 'ARC#HeadersSet';
      return item;
    });
    return result;
  }

  _prepareAuthData(authData) {
    const result = authData.map((item) => {
      item.key = item._id;
      delete item._rev;
      delete item._id;
      item.kind = 'ARC#AuthData';
      return item;
    });
    return result;
  }

  _prepareCookieData(authData) {
    const isElectron = this.electronCookies;
    const result = authData.map((item) => {
      if (!isElectron) {
        item.key = item._id;
        delete item._rev;
        delete item._id;
      }
      item.kind = 'ARC#Cookie';
      return item;
    });
    return result;
  }

  _prepareHostRulesData(hostRules) {
    return hostRules.map((item) => {
      item.key = item._id;
      delete item._rev;
      delete item._id;
      item.kind = 'ARC#HostRule';
      return item;
    });
  }
  /**
   * Checks if `type` is one of the allowed export types defined in
   * `exportType`.
   *
   * @param {String|Array} exportType Export type name or list of export types
   * names allowed to be exported.
   * @param {String} type An export type to test
   * @return {Boolean} True if the `type` is allowed
   */
  _isAllowedExport(exportType, type) {
    if (exportType instanceof Array) {
      return exportType.indexOf(type) !== -1;
    }
    return exportType === type || exportType === 'all';
  }
  /**
   * Creats a map of database name <--> export object key name mapping.
   *
   * @param {String|Array} type Name of the database or list of databases names
   * to export
   * @return {Object} A map where keys are database name and values are
   * export object properties where the data will be put.
   */
  _getDatabasesInfo(type) {
    const databases = {};
    if (this._isAllowedExport(type, 'history')) {
      databases['history-requests'] = 'history';
    }
    if (this._isAllowedExport(type, 'saved')) {
      databases['saved-requests'] = 'requests';
      databases['legacy-projects'] = 'projects';
    }
    if (this._isAllowedExport(type, 'websocket')) {
      databases['websocket-url-history'] = 'websocket-url-history';
    }
    if (this._isAllowedExport(type, 'url-history')) {
      databases['url-history'] = 'url-history';
    }
    if (this._isAllowedExport(type, 'variables')) {
      databases.variables = 'variables';
    }
    if (this._isAllowedExport(type, 'headers-sets')) {
      databases['headers-sets'] = 'headers-sets';
    }
    if (this._isAllowedExport(type, 'auth')) {
      databases['auth-data'] = 'auth-data';
    }
    if (this._isAllowedExport(type, 'cookies')) {
      databases.cookies = 'cookies';
    }
    if (this._isAllowedExport(type, 'host-rules')) {
      databases['host-rules'] = 'host-rules';
    }
    return databases;
  }
  /**
   * Returns all data from a database.
   *
   * @param {String} dbName Name of the datastore t get the data from.
   * @return {Promise} Resolved promise to array of objects. It always
   * resolves.
   */
  _getDatabaseEntries(dbName) {
    const options = {
      limit: this.dbChunk,
      // jscs:disable
      include_docs: true
      // jscs:enable
    };
    /* global PouchDB */
    const db = new PouchDB(dbName);
    let result = [];
    return new Promise((resolve) => {
      function fetchNextPage() {
        db.allDocs(options, function(err, response) {
          if (response && response.rows && response.rows.length > 0) {
            options.startkey = response.rows[response.rows.length - 1].id;
            options.skip = 1;
            const docs = response.rows.map((item) => item.doc);
            result = result.concat(docs);
            return fetchNextPage();
          } else {
            resolve({
              name: dbName,
              data: result
            });
          }
        });
      }
      fetchNextPage();
    });
  }
  /**
   * Requests application to export data to file.
   *
   * @param {Object|String} data Data to export
   * @param {String} file File name
   * @return {Promise}
   */
  _exportFile(data, file) {
    const e = new CustomEvent('file-data-save', {
      cancelable: true,
      bubbles: true,
      composed: true,
      detail: {
        contentType: 'application/json',
        content: data,
        file
      }
    });
    this.dispatchEvent(e);
    if (!e.defaultPrevented) {
      return Promise.reject(new Error('File export module not found.'));
    }
    return e.detail.result;
  }
  /**
   * Requests application to export data to Google Drive.
   *
   * @param {Object|String} data Data to export
   * @param {String} file File name
   * @return {Promise}
   */
  _exportDrive(data, file) {
    const e = new CustomEvent('google-drive-data-save', {
      cancelable: true,
      bubbles: true,
      composed: true,
      detail: {
        contentType: 'application/json',
        content: data,
        file
      }
    });
    this.dispatchEvent(e);
    if (!e.defaultPrevented) {
      return Promise.reject(new Error('Google Drive export module not found.'));
    }
    return e.detail.result;
  }
  /**
   * Fired when any element request to export data outside the application
   *
   * @event file-data-save
   * @param {Any} data The data to export.
   * @param {String} contentType Data content type.
   * @param {String} file Export file name.
   */
  /**
   * Dispatched when file data to be saved on Google Drive.
   *
   * @event google-drive-data-save
   * @param {Any} data The data to export.
   * @param {String} contentType Data content type.
   * @param {String} file Export file name.
   */
}
window.customElements.define(ArcDataExport.is, ArcDataExport);
</script>
